# Story 1.3: Phase Scoring Engine

## Status

Done

## Story

**As** the creator of Timing Terminal  
**I want** a scoring module that computes proprietary Bitcoin phase scores from normalized `PhasePoint` data  
**so that** I can generate reliable 0-100 phase scores and zone classifications for the daily chart.

## Acceptance Criteria

1. **Scoring logic is implemented in a dedicated module**  
   - A `scoring/` package exists under `pipeline/timing_terminal/` containing the phase score calculation logic.  
   - The module exposes a clear interface that accepts `PhasePoint` series and configuration, and returns phase scores and zone classifications.  
   _[Source: docs/architecture.md#Unified Project Structure, #Testing Strategy]_

2. **Phase scores range from 0-100 with clear configuration**  
   - The scoring function produces a float value between 0.0 and 100.0 for each point.  
   - Scoring parameters (weights, thresholds, etc.) are loaded from `config.py` or a dedicated scoring config, not hard-coded.  
   - The implementation is deterministic and repeatable for the same input data.  
   _[Source: docs/architecture.md#Data Models, #Tech Stack]_

3. **Zone classification maps scores to retention/neutral/distribution**  
   - The scoring module includes a function that classifies a phase score into one of three zones: `retention`, `neutral`, `distribution`.  
   - Zone boundaries are configurable (e.g., <20 = retention, 20-80 = neutral, >80 = distribution).  
   - Each `PhasePoint` can be enriched with its zone classification.  
   _[Source: docs/architecture.md#Data Models (PhasePoint, zone field)]_

4. **Unit tests cover scoring logic and zone boundaries**  
   - Unit tests in `pipeline/tests/unit/` verify scoring calculations with known input fixtures.  
   - Tests cover edge cases: minimum scores (0), maximum scores (100), boundary zone transitions.  
   - Tests verify that configuration changes properly affect output scores.  
   _[Source: docs/architecture.md#Testing Strategy (Pipeline Unit Tests)]_

5. **Integration with existing pipeline structure**  
   - The scoring module integrates cleanly with the existing `PhasePoint` and `ChartData` models from Story 1.1.  
   - The CLI can invoke the scoring logic on fixture data to produce phase scores alongside BTC price.  
   - No changes to the JSON schema are required; `phaseScore[]` array is properly populated.  
   _[Source: docs/architecture.md#Data Models (PhasePoint, ChartData)]_

6. **Documentation of scoring methodology**  
   - Dev Notes document the high-level scoring approach and any simplifications made for MVP.  
   - Code includes clear comments explaining the calculation steps.  
   - Future extensibility is noted (e.g., placeholders for additional input series or refined weights).  
   _[Source: docs/architecture.md#External Providers, #Phase-Based Architectural Changes]_

## Tasks / Subtasks

- [x] **Task 1 – Create scoring module structure** (AC: 1, 2)
  - [ ] Create `pipeline/timing_terminal/scoring/` directory with `__init__.py`
  - [ ] Add `phase_score.py` module for core scoring logic
  - [ ] Add `zones.py` module for zone classification logic
  - [ ] Define `ScoringConfig` dataclass in scoring module to hold configurable parameters (weights, zone boundaries, etc.)
  - [ ] Update `pipeline/timing_terminal/config.py` to load scoring configuration from environment or defaults
  _[Source: docs/architecture.md#Unified Project Structure]_

- [x] **Task 2 – Implement phase score calculation** (AC: 2)
  - [ ] Write `compute_phase_score(phase_points: List[PhasePoint], config: ScoringConfig) -> List[float]` function
  - [ ] For MVP, use a simplified scoring formula based on available series (BTC price trends, simulated LTH metrics)
  - [ ] Ensure output is deterministic and bounded [0.0, 100.0]
  - [ ] Load all tunable parameters from `ScoringConfig` (no magic numbers in code)
  - [ ] Add docstrings explaining the scoring approach and parameters
  _[Source: docs/architecture.md#Data Models (PhasePoint), #Tech Stack]_

- [x] **Task 3 – Implement zone classification** (AC: 3)
  - [ ] Write `classify_zone(phase_score: float, config: ScoringConfig) -> str` function
  - [ ] Return `"retention"`, `"neutral"`, or `"distribution"` based on configurable thresholds
  - [ ] Add helper function to enrich `PhasePoint` objects with zone field
  - [ ] Ensure boundaries are configurable via `ScoringConfig`
  _[Source: docs/architecture.md#Data Models (PhasePoint.zone)]_

- [x] **Task 4 – Unit tests for scoring logic** (AC: 4)
  - [ ] Create `pipeline/tests/unit/test_phase_score.py`
  - [ ] Test `compute_phase_score` with known fixture inputs and expected outputs
  - [ ] Test edge cases: empty series, single point, boundary scores (0, 100)
  - [ ] Test configuration changes affect output correctly
  - [ ] Create `pipeline/tests/unit/test_zones.py`
  - [ ] Test zone classification at boundaries (19.9, 20.0, 20.1, 79.9, 80.0, 80.1) and within each zone
  - [ ] Verify custom zone thresholds work as expected
  _[Source: docs/architecture.md#Testing Strategy (Pipeline Unit Tests)]_

- [x] **Task 5 – Integrate scoring into CLI pipeline** (AC: 5)
  - [ ] Update `pipeline/timing_terminal/cli.py` to invoke scoring module on loaded `PhasePoint` data
  - [ ] Populate `ChartData.phaseScore[]` array with computed scores
  - [ ] Ensure time alignment between `btcPrice` and `phaseScore` arrays
  - [ ] Add CLI output showing sample phase scores and zones for verification
  - [ ] Update integration tests in `pipeline/tests/integration/` to verify scoring output in `chart-data.json`
  _[Source: docs/architecture.md#Data Models (ChartData), #Pipeline Integration Tests]_

- [x] **Task 6 – Documentation and comments** (AC: 6)
  - [ ] Add module-level docstrings to `scoring/phase_score.py` and `scoring/zones.py`
  - [ ] Document scoring formula assumptions and MVP simplifications in Dev Notes
  - [ ] Add inline comments for key calculation steps
  - [ ] Note extensibility points for Phase 2 (e.g., incorporating real LTH SOPR/MVRV series)
  _[Source: docs/architecture.md#External Providers, #Phase-Based Architectural Changes]_

## Dev Notes

> This story builds on **Story 1.1 (Data Pipeline Bootstrap)** and **Story 1.2 (Partial Data Handling)**. It introduces the core proprietary logic that transforms normalized price and long-term-holder data into actionable phase scores.

### Architectural Context

- **PhasePoint Model**: Already defined in Story 1.1 with fields `timestamp`, `btc_price`, `phase_score`, `zone`. This story populates the `phase_score` and `zone` fields.  
  _[Source: docs/architecture.md#Data Models (Conceptual Entities)]_

- **ChartData Model**: The `phaseScore[]` array must be populated alongside `btcPrice[]` with matching timestamps for TradingView chart rendering.  
  _[Source: docs/architecture.md#Data Models (ChartData)]_

- **Configuration-Driven Design**: All scoring parameters (weights, zone boundaries) must come from `config.py` or a dedicated `ScoringConfig` to allow tuning without code changes.  
  _[Source: docs/architecture.md#Tech Stack (Backend / Data Pipeline)]_

- **Determinism and Repeatability**: Scoring must be deterministic so that unit and integration tests produce consistent results. No randomness or time-dependent behavior in the scoring function itself.  
  _[Source: docs/architecture.md#Testing Strategy]_

### Scoring Methodology (MVP)

For MVP, the scoring engine will use a **simplified formula** since full external provider integration (real LTH SOPR/MVRV) comes in later stories. Acceptable simplifications:

- Use BTC price momentum or simple moving averages as a proxy for market sentiment.
- Simulate LTH metrics using synthetic or historical patterns for testing purposes.
- Focus on producing well-structured, testable code that can later be enhanced with real data.

**Key Design Principle**: The scoring logic should be modular enough that swapping in real provider data in Story 1.4 requires minimal changes to the scoring module itself.  
_[Source: docs/architecture.md#External Providers, #Phase-Based Architectural Changes]_

### Zone Classification

- **Retention Zone** (low phase score): Typically indicates accumulation, low risk of selling pressure. Decision-critical zone requiring heightened monitoring.
- **Neutral Zone** (mid-range): Market is balanced, no strong directional signal.
- **Distribution Zone** (high phase score): Indicates elevated selling pressure, higher risk. Decision-critical zone requiring heightened monitoring.

Default MVP thresholds:
- Retention: `phase_score < 20`
- Neutral: `20 <= phase_score <= 80`
- Distribution: `phase_score > 80`

These thresholds should be configurable. Note that the <20 and >80 zones are considered **decision-critical** and trigger enhanced monitoring/alerting per the architecture's monitoring strategy.  
_[Source: docs/architecture.md#Data Models (PhasePoint.zone field), #Monitoring as a Testing Backstop]_

### Project Structure Alignment

All scoring code lives under:
```
pipeline/
  timing_terminal/
    scoring/
      __init__.py
      phase_score.py
      zones.py
    config.py  # Updated to include ScoringConfig
  tests/
    unit/
      test_phase_score.py
      test_zones.py
    integration/
      test_cli_chart_data.py  # Extended to verify scoring output
```
_[Source: docs/architecture.md#Unified Project Structure]_

### Previous Story Insights

- **Story 1.1**: Established `PhasePoint` and `ChartData` models, CLI structure, and fixture-based testing. Scoring module should follow the same patterns.
- **Story 1.2**: Introduced `evaluate_data_quality` as a dedicated evaluation function. Similarly, scoring should be a clean, testable function with clear inputs and outputs.

### Testing

- **Unit Tests** (`pipeline/tests/unit/`):
  - Test `compute_phase_score` with known input fixtures (e.g., flat BTC price → mid-range score, uptrending price → higher score).
  - Test edge cases: no data, single data point, score exactly at 0 or 100.
  - Test `classify_zone` with scores at boundaries (19.9, 20.0, 20.1, 79.9, 80.0, 80.1, etc.).
  - Verify configuration changes (e.g., shifting zone boundaries) affect outputs.
  _[Source: docs/architecture.md#Testing Strategy (Pipeline Unit Tests)]_

- **Integration Tests** (`pipeline/tests/integration/`):
  - Extend existing CLI tests to verify that `chart-data.json` includes properly populated `phaseScore[]` arrays.
  - Ensure time alignment: `btcPrice[i].time == phaseScore[i].time` for all points.
  - Verify that zone classifications appear in debug output or logs (if applicable).
  _[Source: docs/architecture.md#Testing Strategy (Pipeline Integration Tests)]_

- **Test Frameworks**:
  - Use `pytest` for all unit and integration tests.
  - Tests should be deterministic and not depend on external API calls (use fixtures).
  _[Source: docs/architecture.md#Tech Stack (Pipeline Testing)]_

### Technical Constraints

- **Python 3.11**: All scoring code must be compatible with Python 3.11.
- **Type Hints**: Use type hints for all function signatures to improve readability and catch errors early.
- **No External Dependencies for Scoring Logic**: Core scoring calculations should not require additional libraries beyond standard Python and existing project dependencies (e.g., no new pip packages for MVP scoring).
- **Performance**: Scoring must complete in reasonable time for daily runs (under 1 second for 365 data points is acceptable for MVP).  
_[Source: docs/architecture.md#Tech Stack]_

### Extensibility Notes

- **Phase 2**: When real LTH SOPR and MVRV data become available (Story 1.2 provider integration), the `compute_phase_score` function should be updated to incorporate these series.
- **Weights and Tuning**: Consider adding a `weights` config field to `ScoringConfig` so relative importance of BTC price vs. LTH metrics can be adjusted.
- **Advanced Models**: Future iterations may use more sophisticated models (e.g., machine learning), but MVP should focus on transparency and simplicity.  
_[Source: docs/architecture.md#Phase-Based Architectural Changes]_

## Dev Agent Record

### Files Modified/Created

- `pipeline/timing_terminal/scoring/__init__.py` - Created ScoringConfig dataclass
- `pipeline/timing_terminal/scoring/phase_score.py` - Implemented compute_phase_score function
- `pipeline/timing_terminal/scoring/zones.py` - Implemented zone classification logic
- `pipeline/timing_terminal/config.py` - Added get_scoring_config() function
- `pipeline/timing_terminal/cli.py` - Integrated scoring module into CLI
- `pipeline/tests/unit/test_phase_score.py` - Created 12 unit tests for phase scoring
- `pipeline/tests/unit/test_zones.py` - Created 11 unit tests for zone classification
- `pipeline/tests/integration/test_cli_chart_data.py` - Added integration test for scoring
- `pipeline/pyproject.toml` - Fixed readme path issue

### Completion Notes

- Implemented MVP scoring using BTC price momentum (30-day window)
- Zone thresholds set to <20 (retention), 20-80 (neutral), >80 (distribution)
- All scoring parameters configurable via ScoringConfig and environment variables
- Scoring is deterministic and bounded [0.0, 100.0]
- CLI now computes phase scores dynamically instead of using hardcoded values
- All tests pass: 32 total (23 unit + 9 integration)
- Code includes comprehensive docstrings and inline comments
- Extensibility notes document future LTH SOPR/MVRV integration

## Change Log

|| Date       | Version | Description                           | Author        |
||------------|---------|---------------------------------------|---------------|
|| 2025-12-09 | v0.1    | Initial draft of Story 1.3 created    | Scrum Master  |
|| 2025-12-09 | v1.0    | Implementation complete, ready for QA | Developer     |

## QA Results

- **Gate Decision:** PASS
- **Scope:** Story 1.3 – Phase Scoring Engine
- **Summary:** All acceptance criteria are satisfied. Scoring logic is deterministic, configuration-driven, and bounded to [0.0, 100.0]. Zone classification behavior (retention/neutral/distribution) matches default and custom thresholds, and is verified at key boundaries. CLI integration produces aligned `btcPrice`/`phaseScore` series and the expected `chart-data.json` schema. Unit and integration tests (32 total) cover core scoring behavior, zone mapping, data-quality semantics, and JSON payload structure.
- **Risks / Notes:** No blocking issues. Future enhancements may be needed when integrating real LTH SOPR/MVRV data; ensure tests remain deterministic via fixtures and extend `ScoringConfig` accordingly.
